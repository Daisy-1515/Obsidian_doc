




## 公式推导
这个问题涉及的是分布式计算中的通信复杂度，尤其是针对图结构的操作。我们来详细推导一下公式 $\alpha \log_d N + B \cdot \frac{M \cdot (N - 1)}{N}$，这个公式的含义是描述在一个 $N$-节点、$d$-规则图中进行 `reduce-scatter` 和 `allgather` 操作的最佳运行时间。
我们假设：
* $N$：节点数目。
* $d$：每个节点的度，即每个节点连接到的其他节点数量。
* $\alpha$：表示通信中每条边的延迟时间，通常是与数据传输的时间成正比的常数。
* $B$：每次传输的数据量（单位时间内能传输的字节数或消息大小）。
* $M$：每个节点需要参与的总消息数。
### 1. **Reduce-Scatter 操作的时间复杂度**
在 `reduce-scatter` 操作中，每个节点将自己的数据与其他节点的数据进行归约操作，并将结果分散到不同的节点上。在 $d$-规则图中，节点之间的通信是通过图的边来进行的。
* **传输延迟**：在 $d$-规则图中，每个节点的连接数为 $d$，如果考虑最坏的情况，节点需要跨越多个通信阶段才能完成整个操作。由于每个节点和其邻居之间的通信延迟是 $\alpha$，所以操作所需的时间主要与图的直径（即最长的通信路径）成正比。
* **图的直径**：对于一个 $d$-规则图，图的直径通常是 $O(\log_d N)$，即 $\log_d N$ 级的通信跳数（路径）。所以，操作的时间复杂度中的一部分是 $\alpha \log_d N$。
### 2. **Allgather 操作的时间复杂度**
在 `allgather` 操作中，所有节点需要将它们的数据传递到每个其他节点。这个过程涉及的数据传输量较大，每个节点将数据发送给其他所有节点。
* **传输时间**：在进行 `allgather` 操作时，节点需要传输的数据量是 $M \cdot (N - 1)$，即每个节点需要与其他 $N-1$ 个节点交换数据。而每次传输的数据量是 $B$，所以总的数据传输量为 $M \cdot (N - 1) \cdot B$。
* **通信开销**：由于每次传输涉及的节点数量为 $N$，因此每条通信的传输时间是 $\frac{M \cdot (N - 1)}{N}$，从而整个操作的时间复杂度的这一部分是 $B \cdot \frac{M \cdot (N - 1)}{N}$。
### 3. **结合两者的时间复杂度**
总的运行时间就是 `reduce-scatter` 和 `allgather` 两个操作时间的和。综合这两个操作的通信延迟，我们得到了以下公式：
$$

\text{运行时间} = \alpha \log_d N + B \cdot \frac{M \cdot (N - 1)}{N}

$$
### 解释
* **第一项**：$\alpha \log_d N$ 代表由于通信延迟和图的结构带来的传输延迟，随着 $N$ 的增加，延迟会增加。
* **第二项**：$B \cdot \frac{M \cdot (N - 1)}{N}$ 代表了与数据传输量和节点数有关的时间复杂度，主要考虑了每个节点需要与其他节点交换数据的量。
因此，最终的公式就是两个部分的综合，描述了在 $d$-规则图中进行 `reduce-scatter` 和 `allgather` 操作的最佳运行时间。



## **Topology Finder**
这段内容讨论了**Topology Finder**（拓扑发现器）在寻找最佳拓扑和调度的过程。其主要目标是为给定的节点数 $N$ 和度数 $d$ 找到最优的网络拓扑和相应的调度策略，以实现最佳的通信性能。以下是该段内容的总结：
### **Topology Finder 的目标和过程：**
1. **目标：**
* **Topology Finder**的目标是为给定的节点数 $N$ 和度数 $d$ 生成最佳的拓扑结构和调度，特别是在大型分布式系统中，优化通信和计算性能。
* 如果目标是**渐近性能**（即固定的 $d$，$N \to \infty$），则希望基础拓扑尽可能大，且基础调度尽可能最优（见定理 9）。
1. **基础拓扑和调度：**
* 对于给定的目标 $N$ 和 $d$，只有特定大小和度数的基础拓扑（如 $N$ 的除数）可以扩展到目标拓扑。因此，**Topology Finder**使用一个已知的基础拓扑和调度的数据库（见表 9），这些拓扑和调度已被高度优化，覆盖了广泛的 $N$ 和 $d$。
1. **搜索过程：**
* 在给定的基础拓扑的基础上，**Topology Finder**进行自下而上的搜索，查找不同拓扑扩展技术的组合，以达到目标节点数 $N$ 和度数 $d$。
* 这个过程是**迭代的**，每次扩展都会生成一个新的拓扑，随着拓扑的增长，逐步修剪出性能不佳的候选，保留性能最优的拓扑进行进一步扩展。
1. **性能预测：**
* 由于生成所有可能拓扑并比较其性能的过程是不可行的，**Topology Finder**通过使用已证明的定理来预测扩展拓扑的性能。这使得在搜索过程中可以通过**分析公式**来预测和比较不同拓扑的性能，从而进行有效的修剪，保留那些性能最优的拓扑。
* 这种预测方法是**非常重要**的，尤其是在面对大规模拓扑扩展时，可以避免构建每个拓扑并进行实际测试，从而加速搜索过程。
1. **Pareto 前沿：**
* **Pareto 前沿**是搜索过程中记录的最优拓扑集合。一个拓扑被认为是**劣势的**，只有在\*\*总跳数延迟（TL）**和**带宽运行时间（TB）\*\*都比另一个拓扑差时，才会被认为是劣势的。
* 搜索的结果会找到**所有Pareto高效的拓扑**，它们在目标 $N$ 和 $d$ 下表现最优。
1. **实践中的应用：**
* 由于不同拓扑的调整和选择可能需要较高的重新配置延迟，**Topology Finder**通常会在训练开始时选择一个最优拓扑，并在整个训练过程中使用该拓扑。对于快速重新配置的情况，可以在训练过程中根据不同的通信模式动态调整拓扑。
1. **性能评估与测试：**
* 在表 4 中，展示了\*\*$N = 1024$ 和 $d = 4$**时，Pareto前沿的结果。表格显示了不同拓扑的**总延迟（TL）**和**带宽延迟（TB）**，并对比了它们的性能。优化的拓扑使得在**Allreduce**操作中的延迟保持最低，尽管某些拓扑的直径较小，但它们的**全对全通信（All-to-All）\*\*时间表现仍然优于其他拓扑。
* 例如，**L3(C(16, {3, 4}))**的线图（Line Graph）具有最低的**Allreduce**和**All-to-All**时间，且接近理论界限。
1. **效率与搜索范围：**
* **Topology Finder**的实现可以在一分钟内完成所有 $d = 2, 4, 8, 16$ 和 $N$ 达到 2000 的搜索。虽然可以进一步加速，但目前的速度足够接受，因为这些搜索只需进行一次，并且结果可以保存供未来使用。

### **总结：**
* **Topology Finder** 旨在为给定的 $N$ 和 $d$ 找到最优的网络拓扑和调度方案，通过优化通信性能，特别是在大规模并行计算中，减少延迟并提高带宽效率。
* 它通过数据库中已优化的基础拓扑和调度进行搜索，并根据性能预测和分析公式修剪不良拓扑，从而高效地找到最优拓扑。
* 在实际应用中，能够根据工作负载的需求选择最合适的拓扑，并且可以根据重新配置延迟选择是否在训练过程中动态调整拓扑。




![[Snipaste_2025-10-30_14-24-43.png]]





# related work
* [[分布式训练中All-Reduce、All-Gather、Reduce-Scatter原理介绍]]
* [[图论碎片知识点]]